//============================================================================
// Name        : blender2oGL_MassSpring.cpp
// Author      : Gerhard Aigner
// Version     :
// Copyright   : @
// Description : Converting tool to create c source and header files of
//               OpenGL rendered masses and springs from an .obj file supplied
//               by blender.
//============================================================================

#include <sys/types.h>
#include <cstddef>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <cstring>
#include <algorithm>

using namespace std;

/**
 * Objects of this class represent a single 3D graphics object.
 * Write methods will generate C-source and header files for OpenGL integration.
 */
class Object3dModel {
	friend class ObjFileReader;

public:
	Object3dModel(size_t nPositions,
			      size_t nTexels,
				  size_t nNormals,
				  size_t nFaces,
				  bool isMassSpring = false) :
		nPositions(nPositions),
		nTexels(nTexels),
		nNormals(nNormals),
		nFaces(nFaces),
		nVertices(nFaces * 3),
		massSpring(isMassSpring),
		positions(new float[nPositions * 3]),
		texels(new float[nTexels * 2]),
		normals(new float[nNormals * 3]),
		faces(new int[nFaces * 9])  {}

	~Object3dModel() {}

	void writeHfile(string folderPath, ostream* logfp = &cout);
	void writeCfile(string folderPath, ostream* logfp = &cout);
	bool isMassSpring();
	void setMassSpring();
	void unsetMassSpring();
	bool hasConvertedPolygons();
	void writeStatistics(ostream* fp = &cout);

	string name;

private:
	void writeHeader(ofstream* fp, bool isHfile = false);
	void writeCpositions(ofstream* fp);
	void writeCtexels(ofstream* fp);
	void writeCnormals(ofstream* fp);
	void writeCmasses(ofstream* fp);
	void writeCsprings(ofstream* fp);

	size_t nPositions;
	size_t nTexels;
	size_t nNormals;
	size_t nFaces;
	size_t nVertices;
	bool massSpring;          ///< object with masses and springs
	bool hasConvPoly = false; ///< this object contains from polygons converted triangles
	float* positions;         ///< size: nPositions * 3
	float* texels;            ///< size: nTexels * 2
	float* normals;           ///< size: nNormals * 3
	int* faces;               ///< size: nFaces * 9
};

/**
 * Reader class with capabilities to extract multiple 3D graphics objects
 * from a .obj file generated by blender.
 */
class ObjFileReader {

public:
	ObjFileReader(string path, bool inFileNameAsPrefix = true) :
		path(path), prefix(inFileNameAsPrefix ? "_" : "") {}

	~ObjFileReader() {}

	Object3dModel read();
	bool hasNext();

private:
	void init();
	inline void tokenize(const string& line, const size_t n,
			float data[], size_t p);

	vector<string> objects;
	string path;
	string prefix;        ///< use input filename as prefix for object names
	size_t offset = 0;    ///< offset to read from input file
	size_t objNo = 0;     ///< the object to read
	bool isInit = false;  ///< guard for initialization
	size_t vOffs = 0;     ///< indices are continuous for all objects in the same file, store the offset here; vertices
	size_t tOffs = 0;     ///< offset for index correction: texels vector
	size_t nOffs = 0;     ///< offset for index correction: normals vector
};

void ObjFileReader::tokenize(const string& line, const size_t n,
		float data[], size_t p) {
	char* l = new char[line.size() + 1];
	memcpy(l, line.c_str(), line.size() + 1);
	strtok(l, " ");
	for (size_t i = 0; i < n; ++i) {
		data[n * p + i] = atof(strtok(nullptr, " "));
	}
	delete[] l;
}

/**
 * @brief Read data from .obj file and build an instance of Object3dModel.
 *
 * This method extracts the data of one 3D object and maintains the internal state of the ObjFileReader.
 *
 * @return the Object3dModel instance
 */
Object3dModel ObjFileReader::read() {
	if (hasNext()) {
		size_t p = 0;
		size_t t = 0;
		size_t n = 0;
		size_t f = 0;

		ifstream fObj;
		size_t offs = offset;
		fObj.open(path.c_str());
		if (fObj.good()) {
			fObj.seekg(offs);
			// count all entries from offset until next "o " line
			string line;
			bool done = false;
			bool warnConverted = false;

			while (!fObj.eof() && !done) {
				getline(fObj, line);
				offs = fObj.tellg();
				string entry = line.substr(0, 2);

				if (entry.compare("o ") == 0) {
					done = true;
				} else if (entry.compare("v ") == 0) {
					++p;
				} else if (entry.compare("vt") == 0) {
					++t;
				} else if (entry.compare("vn") == 0) {
					++n;
				} else if (entry.compare("f ") == 0) {
					char* l = new char[line.size()+1];
					memcpy(l, line.c_str(), line.size()+1);
					strtok(l, " ");
					int cnt = 0;
					while(strtok(nullptr, " ") != nullptr) ++cnt;
					delete[] l;
					f += cnt - 2;
					if (cnt > 3) warnConverted = true;
				}
			}
			// read data
			Object3dModel model = Object3dModel(p, t, n, f);
			model.name = string(objects[objNo]);
			model.hasConvPoly = warnConverted;
			done = false;
			offs = offset;
			fObj.clear();
			fObj.seekg(offs);
			p = 0;
			t = 0;
			n = 0;
			f = 0;
			while (!fObj.eof() && !done) {
				getline(fObj, line);
				offs = fObj.tellg();
				string entry = line.substr(0, 2);
				if (entry.compare("o ") == 0) {
					offset = offs;
					done = true;
				} else if (entry.compare("v ") == 0) { // Points: 'v <x> <y> <z>'
					tokenize(line, 3, model.positions, p);
					++p;
				} else if (entry.compare("vt") == 0) { // Texels: 'vt <u> <v>'
					tokenize(line, 2, model.texels, t);
					++t;
				} else if (entry.compare("vn") == 0) { // Normals: 'vn <x> <y> <z>'
					tokenize(line, 3, model.normals, n);
					++n;
				} else if (entry.compare("f ") == 0) { // faces: 'f X/T/N Y/T/N Z/T/N'
					// command format: f position_id/texture_coordinates_id/normal_id
					// possibly no texture coordinates available: fill with 0;
					// caution: all coordinates start with 1, so correct it by -1 if translated to array indices
					// if multiple objects are in a .obj file then all positions, texels and normals are indexed sequently,
					// so, the indices need to be corrected by the offset given by the array sizes of all previous objects.
					char* l = new char[line.size()+1];
					memcpy(l, line.c_str(), line.size()+1);
					strtok(l, " ");
					int cnt = 0;
					int temp[9];
					char* tok;
					while((tok = strtok(nullptr, " ")) != nullptr) {
						// store first vertex in temp[0..2], then toggle between temp[3..5] and temp[6..8]
						int i = cnt > 0 ? (1-cnt%2)*3+3 : 0;
						temp[i] = atoi(tok);
						tok = strchr(tok, '/')+1;
						temp[i+1] = atoi(tok);
						tok = strchr(tok, '/')+1;
						temp[i+2] = atoi(tok);

						// write face
						if (cnt >=2) {
							// vertex 1: take always the first index triplet P/T/N
							model.faces[9*f] = temp[0] - vOffs - 1;
							model.faces[9*f+1] = temp[1] - tOffs - 1;
							model.faces[9*f+2] = temp[2] - nOffs - 1;
							// vertex 2: take temp[3]..temp[5] if cnt even, otherwise use temp[6]..temp[8]
							model.faces[9*f+3] = temp[cnt%2*3+3] - vOffs - 1;
							model.faces[9*f+4] = temp[cnt%2*3+4] - tOffs - 1;
							model.faces[9*f+5] = temp[cnt%2*3+5] - nOffs - 1;
							// vertex 3: take opposite part of vertex 2 in range of temp[3..8], they're updated alternating
							model.faces[9*f+6] = temp[(1-cnt%2)*3+3] - vOffs - 1;
							model.faces[9*f+7] = temp[(1-cnt%2)*3+4] - tOffs - 1;
							model.faces[9*f+8] = temp[(1-cnt%2)*3+5] - nOffs - 1;
							++f;
						}
						++cnt;
					}
					delete[] l;
				}
			}
			fObj.close();
			// update state for next object to read
			++objNo;
			vOffs += model.nPositions;
			tOffs += model.nTexels;
			nOffs += model.nNormals;
			return model;
		} else {
			throw runtime_error("Error reading file.");
		}
	} else {
		throw runtime_error("No data for generating object.");
	}
}

/**
 * Check if objects are available
 *
 * @retval true {if an object is available}
 * @retval false {otherwise}
 */
bool ObjFileReader::hasNext() {
	if (!isInit) {
		init();
	}
	return objNo < objects.size();
}

/**
 * @brief Initialize the ObjFileReader object.
 *
 * The method reads all entries of type "o" (object) and sets the initial stream-offset.
 */
void ObjFileReader::init() {
	if (!isInit) {
		// prefix for object names
		if (prefix.compare("_") == 0) {
			size_t start = path.find_last_of('/');
			if (start > path.size()) start = 0; // no '/' found --> take whole string
			prefix = path.substr(start + 1, path.find_last_of('.') - start - 1);
			prefix.append("_");
		}

	    // read object names
		ifstream fObj;
		size_t offs = 0;
		fObj.open(path.c_str());
		if (fObj.good()) {
			// read all "o " entries and store them as object names
			string line;
			while (!fObj.eof()) {
				getline(fObj, line);
				offs = fObj.tellg();
				string entry = line.substr(0, 2);
				if (entry.compare("o ") == 0) {
					if (offset == 0) {
						// set initial stream-offset
						offset = offs;
					}
					size_t end = line.find_last_not_of(" \t");
					string obj = prefix;
					objects.push_back(obj.append(line.substr(2, end-1))); // end-(start=2)+1
				}
			}
			fObj.close();
		} else {
			throw runtime_error("Error reading file.");
		}
		isInit = true;
	}
}

/**
 * Generate a header file for the 3D-model.
 * @param folderPath the target folder
 * @param logfp output to log file (nullptr to suppress output)
 */
void Object3dModel::writeHfile(string folderPath, ostream* logfp) {
	ofstream fp;
	string path = folderPath;
    string sep = folderPath[folderPath.size()-1] == '/' ? "" : "/";
	path.append(sep).append(name).append(".h");

	fp.open(path.c_str());
	if (fp.good()) {
	    *logfp << "generating header file ... " << flush;

		// headlines and statistics
		writeHeader(&fp, true);

		// include guards
		string hdr = name;
		transform(hdr.begin(), hdr.end(), hdr.begin(), ::toupper);
		fp << "#ifndef __" << hdr << "_H__\n";
		fp << "#define __" << hdr << "_H__\n\n";

	    // declarations
	    fp << "const int " << name << "Vertices;\n";
	    fp << "const float " << name << "Positions[" << nVertices*3 << "];\n";
	    fp << "const float " << name << "Texels[" << nVertices*2 << "];\n";
	    fp << "const float " << name << "Normals[" << nVertices*3 << "];\n\n";//FIXME use indices

	    if (massSpring) {
		    fp << "const float " << name << "Masses[" << nVertices << "];\n";
		    fp << "const float " << name << "Springs[" << nVertices*2 << "];\n\n";//FIXME size
		}

	    // include guards
	    fp << "#endif" << endl;

		*logfp << "done." << endl;
		*logfp << "written to \"" << path << "\"" << endl;

	    fp.close();
	} else {
		throw runtime_error("Error writing header file:" + path);
	}
}

/**
 * Generate a source file for the 3D-model.
 * @param folderPath the target folder
 * @param logfp output to log file (nullptr to suppress output)
 */
void Object3dModel::writeCfile(string folderPath, ostream* logfp) {
	ofstream fp;
	string path = folderPath;
    string sep = folderPath[folderPath.size()-1] == '/' ? "" : "/";
	path.append(sep).append(name).append(".c");

	fp.open(path.c_str());
	if (fp.good()) {
	    *logfp << "generating source file ... " << flush;
		// headlines and statistics
		writeHeader(&fp);

		// header
	    fp << "#include " << "\"" << name << ".h" << "\"\n\n";

	    // vertices
	    fp << "const int " << name << "Vertices = " << nVertices << ";\n";
	    fp << endl;

	    *logfp << "positions ... " << flush;
		writeCpositions(&fp);
		*logfp << "texels ... " << flush;
		writeCtexels(&fp);
		*logfp << "normals ... " << flush;
		writeCnormals(&fp);

		if (massSpring) {
			*logfp << "masses ... " << flush;
			writeCmasses(&fp);
			*logfp << "springs ... " << flush;
			writeCsprings(&fp);
		}
		*logfp << "done." << endl;
		*logfp << "written to \"" << path << "\"" << endl;

	    fp.close();
	} else {
		throw runtime_error("Error writing source file:" + path);
	}
}

/**
 * Check if masses and springs structures are to generate in output files.
 * @retval true {create masses and springs data structures}
 * @retval false {write only data for solid objects}
 */
bool Object3dModel::isMassSpring() {
	return massSpring;
}

/**
 * Change object state to mass-spring model.
 */
void Object3dModel::setMassSpring() {
	massSpring = true;
}

/**
 * Change object state to solid model.
 */
void Object3dModel::unsetMassSpring() {
	massSpring = false;
}

/**
 * Check if .obj file contained polygons which have been converted to triangles.
 *
 * OpenGL supports polygon faces with an arbitrary number of vertices. To avoid
 * artefacts caused by putting a texture onto a non planar surface these polygons
 * are converted to a fan of triangles.
 *
 * @retval true {contains at least one converted polygon}
 * @retval false {only triangle shaped faces extracted from .obj file}
 */
bool Object3dModel::hasConvertedPolygons() {
	return hasConvPoly;
}

/**
 * Print a summary of the 3D model
 */
void Object3dModel::writeStatistics(ostream* fp) {
	*fp << "/*\n";
	*fp << " * model statistics:\n";
	*fp << " * name: \"" << name << "\"\n";
	*fp << " * # positions = " << nPositions << "\n";
	*fp << " * # texels    = " << nTexels << "\n";
	*fp << " * # normals   = " << nNormals<< "\n";
	*fp << " * # faces     = " << nFaces << "\n";
	if (hasConvPoly) {
		*fp << " * contains converted polygons of triangle fan shape" << "\n";
	}
	if (massSpring) {
		*fp << " * includes masses and springs structures\n";
	}
	*fp << " */" << endl;
}

/**
 * Generate a header for the C files.
 * @param fp target file
 * @param isHfile @c true for .h file, @c false for .c file
 */
void Object3dModel::writeHeader(ofstream* fp, bool isHfile) {
    *fp << "// This is a ";
    if (isHfile) {
    	*fp << "C-header file (.h)";
    } else {
    	*fp << "C-source file (.c)";
    }
    *fp << " for the model \"" << name << "\"\n";
    *fp << "// Don't edit! This is an auto-generated file by blender2oGL. Modifications are not permanent.\n\n";
    writeStatistics(fp);
    *fp << endl;
}

/**
 * Generate positions array
 * @param fp target c-file
 */
void Object3dModel::writeCpositions(ofstream* fp) {
    *fp << "const float " << name << "Positions[" << nVertices*3 << "] = {\n";
    for(size_t i=0; i<nFaces; ++i) {
        int a = faces[9*i]*3;
        int b = faces[9*i+3]*3;
        int c = faces[9*i+6]*3;

        *fp << "\t" << positions[a] << ", " << positions[a+1] << ", " << positions[a+2] << ",\n";
        *fp << "\t" << positions[b] << ", " << positions[b+1] << ", " << positions[b+2] << ",\n";
        *fp << "\t" << positions[c] << ", " << positions[c+1] << ", " << positions[c+2] << "," << endl;
    }
    *fp << "};\n" << endl;
}

/**
 * Generate texels array
 * @param fp target c-file
 */
void Object3dModel::writeCtexels(ofstream* fp){
    *fp << "const float " << name << "Texels[" << nVertices*2 << "] = {\n";
    for(size_t i=0; i<nFaces; ++i) {
        int a = faces[9*i+1]*2;
        int b = faces[9*i+4]*2;
        int c = faces[9*i+7]*2;

        if (a<0 || b<0 || c<0) {
        	*fp << "\t0, 0,\n\t0, 0,\n\t0, 0," << endl;
        } else {
			*fp << "\t" << texels[a] << ", " << texels[a+1] << ",\n";
			*fp << "\t" << texels[b] << ", " << texels[b+1] << ",\n";
			*fp << "\t" << texels[c] << ", " << texels[c+1] << "," << endl;
        }
    }
    *fp << "};\n" << endl;
}

/**
 * Generate normals array
 * @param fp target c-file
 */
void Object3dModel::writeCnormals(ofstream* fp) {
    *fp << "const float " << name << "Normals[" << nVertices*3 << "] = {\n";
    for(size_t i=0; i<nFaces; ++i) {
        int a = faces[9*i+2]*3;
        int b = faces[9*i+5]*3;
        int c = faces[9*i+8]*3;

        *fp << "\t"  << normals[a] << ", " << normals[a+1] << ", " << normals[a+2] << ",\n";
        *fp << "\t"  << normals[b] << ", " << normals[b+1] << ", " << normals[b+2] << ",\n";
        *fp << "\t"  << normals[c] << ", " << normals[c+1] << ", " << normals[c+2] << "," << endl;
    }
    *fp << "};\n" << endl;
}

/**
 * Generate masses array
 * @param fp target c-file
 */
void Object3dModel::writeCmasses(ofstream* fp) {
	// TODO stub
}

/**
 * Generate sprngs array
 * @param fp target c-file
 */
void Object3dModel::writeCsprings(ofstream* fp) {
	// TODO stub
}

/**
 * Print an error message, usage information and exit with error state.
 * @param argv the arguments vector
 * @param msg an optional error message
 */
inline void exitErr(char* argv[], string msg = "") {
	cerr << msg << endl;
	cerr << "USAGE: " << argv[0] << " source-file.obj target-folder" << endl;
	cerr << "Hint: don't use shortcuts like ~ or %HOMEPATH%" << endl;
	exit(EXIT_FAILURE);
}

/**
 * Print a warning message to an output stream if model contains converted polygons.
 * @param model the 3D-model
 * @param logfp output stream to logfile
 */
void warnIfConvertedFaces(Object3dModel model, ostream* logfp = &cout) {
	if (model.hasConvertedPolygons()) {
		*logfp << "Warning: \"" << model.name
				<< "\" contains to triangles converted polygon faces." << endl;
	}
}

/**
 * @brief The main function.
 *
 * Two arguments are obligatory:
 * --> source-file.obj - the path to the .obj file
 * --> target-folder   - the path to the destination folder
 *
 * @param argc arguments count
 * @param argv arguments vector
 * @return exit status for caller
 */
int main(int argc, char* argv[]) {
    // Files
	if (argc < 3) {
		exitErr(argv);
	}
    string srcPath = argv[1];
    string dstPath = argv[2];

    cout << "source file: " << srcPath << endl;

    int n = 0;
    ObjFileReader reader = ObjFileReader(srcPath);
    try {
    	while (reader.hasNext()) {
    		Object3dModel model = reader.read();
    		cout << "\nprocessing model \"" << model.name << "\"" << endl;
    		warnIfConvertedFaces(model);
    		model.writeHfile(dstPath);
    		model.writeCfile(dstPath);
//    		model.writeStatistics();
    		++n;
    	}
    	cout << "\nprocessed " << n << " 3D-models." << endl;
    } catch (exception& e) {
    	exitErr(argv, e.what());
    }
    return EXIT_SUCCESS;
}
